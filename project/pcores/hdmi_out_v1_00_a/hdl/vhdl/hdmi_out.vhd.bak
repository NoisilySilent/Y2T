
----------------------------------------------------------------------------
--	hdmi_out.vhd -- Hdmi Output Core
----------------------------------------------------------------------------
-- Author:  Sam Bobrowicz
--          Referenced Work by Tinghui WANG (Steve)
--          Copyright 2011 Digilent, Inc.
----------------------------------------------------------------------------
--
----------------------------------------------------------------------------
--
--Description:
--   Outputs data stored in a framebuffer using the TMDS standard. The frame
--   is accessed via a VFBC PIM on an MPMC core.
--
--Sync Signal Register Definitions:
--
--    0     hsr           hbpr                hfpr         htr
--    | Sync |--------------|-------------------|------------
--    |------|  Back Porch  |   active video    | Front Porch
--	 														
----------------------------------------------------------------------------
--
----------------------------------------------------------------------------
-- Revision History:
--  10/24/2011(SamB): Created for use with Xilinx EDK 13.2
----------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;

entity hdmi_out is
generic
(
  FRAME_BASE_ADDR                : std_logic_vector(31 downto 0)     := x"00000000";
  LINE_STRIDE                    : std_logic_vector(23 downto 0)     := x"000000";
  RESOLUTION_SELECT              : integer := 1);
port
(
	PXLCLK_I : in std_logic;
	PXLCLK_2X_I : in std_logic;
	PXLCLK_10X_I : in std_logic;
   LOCKED_I : in std_logic;
	-- ports pour hdmi_in
   FB_SELECT : in std_logic_vector(1 downto 0);
   IN_PXL_CNT : in std_logic_vector(31 downto 0);
	FRAME_RST : in std_logic;
	 -- HDMI ports
    TMDS : out std_logic_vector(3 downto 0);
    TMDSB : out std_logic_vector(3 downto 0);
    -- VFBC Cmd Ports
    VFBC_CMD_CLK : out std_logic;
    VFBC_CMD_IDLE : in std_logic;
    VFBC_CMD_RESET : out std_logic;
    VFBC_CMD_DATA : out std_logic_vector (31 downto 0);
    VFBC_CMD_WRITE : out std_logic;
    VFBC_CMD_END : out std_logic;
    VFBC_CMD_FULL : in std_logic;
    VFBC_CMD_ALMOST_FULL : in std_logic;
    -- VFBC Read Ports
    VFBC_RD_CLK : out std_logic;
    VFBC_RD_RESET : out std_logic;
    VFBC_RD_FLUSH : out std_logic;
    VFBC_RD_READ : out std_logic;
    VFBC_RD_END_BURST : out std_logic;
    VFBC_RD_DATA : in std_logic_vector (15 downto 0);
    VFBC_RD_EMPTY : in std_logic;
    VFBC_RD_ALMOST_EMPTY : in std_logic);


  attribute MAX_FANOUT : string;
  attribute SIGIS : string;
  
  attribute SIGIS of PXLCLK_I    : signal is "CLK";
  attribute SIGIS of PXLCLK_2X_I    : signal is "CLK";
  attribute SIGIS of PXLCLK_10X_I    : signal is "CLK";

end entity hdmi_out;

architecture IMP of hdmi_out is
  
  COMPONENT dvi_out_native
  PORT(
		reset : IN std_logic;
		pll_lckd : IN std_logic;
		clkin : IN std_logic;
		clkx2in : IN std_logic;
		clkx10in : IN std_logic;
		blue_din : IN std_logic_vector(7 downto 0);
		green_din : IN std_logic_vector(7 downto 0);
		red_din : IN std_logic_vector(7 downto 0);
		hsync : IN std_logic;
		vsync : IN std_logic;
		de : IN std_logic;          
		TMDS : OUT std_logic_vector(3 downto 0);
		TMDSB : OUT std_logic_vector(3 downto 0)
		);
  END COMPONENT;
  
  constant vfbc_cmd3 : std_logic_vector(31 downto 0) := "0000000" & LINE_STRIDE(23 downto 7) & "00000000";  --The line stride must be 128 byte alligned and be in bytes (2x input)
  
  constant RES_640_480 : integer := 1;
  constant RES_800_600 : integer := 2; --Currently not supported; need support for non-128 byte alligned widths
  constant RES_1280_720 : integer := 3;
  
  signal vfbc_cmd0 : std_logic_vector(31 downto 0);
  signal vfbc_cmd1 : std_logic_vector(31 downto 0);
  signal vfbc_cmd2 : std_logic_vector(31 downto 0);
  
  signal htr : std_logic_vector(15 downto 0);
  signal vtr : std_logic_vector(15 downto 0);
  signal hvtr : std_logic_vector(31 downto 0);
  signal hsr : std_logic_vector(15 downto 0);
  signal vsr : std_logic_vector(15 downto 0);
  signal hfpr : std_logic_vector(15 downto 0);
  signal vfpr : std_logic_vector(15 downto 0);
  signal hbpr : std_logic_vector(15 downto 0);
  signal vbpr : std_logic_vector(15 downto 0);
  signal hlr  : std_logic_vector(15 downto 0);

  signal polarity : std_logic;
  
  signal pxlclk : std_logic;
  signal pxlclk_2x : std_logic;
  
  signal enabled : std_logic := '1';
  
  signal vfbc_cmd_data_i : std_logic_vector(31 downto 0);
  signal vfbc_cmd_write_i : std_logic; 
  signal vfbc_rd_reset_i : std_logic;
  
  signal hcnt : std_logic_vector(0 to 13) := (others => '0');
  signal vcnt : std_logic_vector(0 to 13) := (others => '0');
  signal pcnt : std_logic_vector(31 downto 0);
  signal fb_chg_cnt : std_logic_vector(31 downto 0) := (others => '0');
  
  signal hsync_i : std_logic;
  signal vsync_i : std_logic;
  signal hsync_d1 : std_logic;
  signal vsync_d1 : std_logic;
  signal hsync_d2 : std_logic;
  signal vsync_d2 : std_logic;
  signal hblank_i : std_logic;
  signal vblank_i : std_logic;
  signal active_video_i : std_logic;
  signal video_data_i : std_logic_vector(23 downto 0);
  signal active_video_d1 : std_logic;
  signal active_video_d2 : std_logic;
  signal video_data_d1 : std_logic_vector(23 downto 0);
  
  signal unused_dout       : std_logic_vector(15 downto 0);
  signal line_buffer_dout  : std_logic_vector(15 downto 0);
  signal line_buffer_waddr : std_logic_vector(9 downto 0);
  signal line_buffer_raddr : std_logic_vector(9 downto 0);
  
  signal frame_reset             : std_logic;
  signal frame_reset_reg         : std_logic;
  signal frame_reset_cnt         : std_logic_vector(15 downto 0) := (others => '0');
  signal no_input_signal         : std_logic := '1';
  signal frame_buffer_out        : std_logic_vector(1 downto 0);
  signal frame_buffer_in         : std_logic_vector(1 downto 0);
  signal frame_buffer_in_reg     : std_logic_vector(1 downto 0);
  
  signal input_pxl_cnt              : std_logic_vector(31 downto 0);
  signal input_pxl_cnt_reg          : std_logic_vector(31 downto 0);
  signal no_input_cnt            : std_logic_vector(15 downto 0) := (others => '0');
  signal no_input                : std_logic := '1';
  
begin

  vfbc_cmd0 <= x"00000A00";
  vfbc_cmd2 <= x"000002CF";
  
  polarity <= '1';

  pxlclk_2x <= PXLCLK_2X_I;
  pxlclk <= PXLCLK_I;
  frame_buffer_in <= FB_SELECT;
  input_pxl_cnt <= IN_PXL_CNT;
  frame_reset <= FRAME_RST;
  
  hvtr <= x"00127B72"; -- htr * vtr
 
  hsr  <= x"0005"; --5
  hbpr <= x"00E1"; --225
  hfpr <= x"05E1"; --1505
  htr  <= x"064F"; --1615
  
  vsr  <= x"0005"; --5
  vbpr <= x"0019"; --25
  vfpr <= x"02E9"; --745
  vtr  <= x"02EE"; --750
		
  hlr <= x"0361"; --865
  
  FRAME_BASE_ADDR_PROC : process (pxlclk) is
  begin
    if rising_edge(pxlclk) then
      if (frame_buffer_out = "00") then
        vfbc_cmd1 <= x"49000000";
      elsif (frame_buffer_out = "01") then 
        vfbc_cmd1 <= x"491C2000";
      elsif (frame_buffer_out = "10") then
        vfbc_cmd1 <= x"49384000";
		elsif (frame_buffer_out = "11") then
        vfbc_cmd1 <= x"49546000";
      end if;
    end if;
  end process FRAME_BASE_ADDR_PROC;
  
  --HV_CNT_PROC : horizontal and vertical counter
  HV_CNT_PROC: process (pxlclk) is
  begin
	 if rising_edge(pxlclk) then
		if LOCKED_I = '0' or enabled = '0' then
		  hcnt <= (others => '0');
		  vcnt <= (others => '0');
		  pcnt <= (others => '0');
		else
		  if pcnt < hvtr then
			 if hcnt < htr then
				hcnt <= hcnt + 1;
			 else
				hcnt <= (others => '0');
				vcnt <= vcnt + 1;
			 end if;
			 pcnt <= pcnt + 1;
		  else
          case frame_buffer_in is
            when "00" => frame_buffer_out <= "10";
            when "01" => frame_buffer_out <= "11";
            when "10" => frame_buffer_out <= "00";
            when "11" => frame_buffer_out <= "01";
       		when others => frame_buffer_out <= "10";
          end case;
          hcnt <= (others => '0');
		    vcnt <= (others => '0');
		    pcnt <= (others => '0');
		  end if;
		end if;
	 end if;
  end process HV_CNT_PROC;

  --Assign ALL video Signals
  hsync_i <= polarity when (hcnt < hsr) else
				 not(polarity);
  vsync_i <= polarity when (vcnt < vsr) else
				 not(polarity);
  hblank_i <= '1' when (hcnt >= hbpr) and (hcnt < hfpr) else
				  '0';
  vblank_i <= '1' when (vcnt >= vbpr) and (vcnt < vfpr) else
				  '0';
  active_video_i <= hblank_i and vblank_i;
  
  --DELAYED OUTPUT for ALL video signals
  VIDEO_DELAY_PROC : process (pxlclk) is
  begin
	if rising_edge(pxlclk) then
		if LOCKED_I = '0' or enabled = '0' then
			hsync_d2 <= '0';
			vsync_d2 <= '0';
			hsync_d1 <= '0';
			vsync_d1 <= '0';
			active_video_d2 <= '0';
			active_video_d1 <= '0';
			video_data_d1 <= (others => '0');
		else
			hsync_d2 <= hsync_d1;
			hsync_d1 <= hsync_i;
			vsync_d2 <= vsync_d1;
			vsync_d1 <= vsync_i;
         active_video_d2 <= active_video_d1;
			active_video_d1 <= active_video_i;
			video_data_d1 <= video_data_i;
		end if;
	end if;
  end process VIDEO_DELAY_PROC;

  NO_INPUT_CNT_PROC : process (pxlclk) is
  begin
	if rising_edge(pxlclk) then
	  if input_pxl_cnt_reg /= input_pxl_cnt then
	    no_input_cnt <= (others => '0');
	  elsif no_input_cnt < x"FFFF" then
	    no_input_cnt <= no_input_cnt + 1;
	  end if;
	  if no_input_cnt = x"FFFF" then
	    no_input <= '1';
	  else
	    no_input <= '0';
	  end if;
	  input_pxl_cnt_reg <= input_pxl_cnt;
	end if;
  end process NO_INPUT_CNT_PROC;

  video_data_i <= (others => '0') when no_input = '1' else
                  line_buffer_dout(7 downto 3) & "000" & line_buffer_dout(2 downto 0) & line_buffer_dout(15 downto 13) & "00" & line_buffer_dout(12 downto 8) & "000";
  
  --Instantiate TMDS encoder
  Inst_dvi_out_native: dvi_out_native PORT MAP(
		reset => '0',
		pll_lckd => LOCKED_I,
		clkin => pxlclk,
		clkx2in => pxlclk_2x,
		clkx10in => PXLCLK_10X_I,
		blue_din => video_data_d1(23 downto 16),
		green_din => video_data_d1(15 downto 8),
		red_din => video_data_d1(7 downto 0),
		hsync => hsync_d2,
		vsync => vsync_d2,
		de => active_video_d2,
		TMDS => TMDS,
		TMDSB => TMDSB
	);

  --------------------------------
  -- VFBC Command Logic
  --------------------------------

  VFBC_CMD_CLK <= pxlclk;
  VFBC_CMD_RESET <= '1' when LOCKED_I = '0' else
						  '0'; -- reset at the very beginning
  VFBC_CMD_DATA <= vfbc_cmd_data_i;
  VFBC_CMD_WRITE <= vfbc_cmd_write_i;
  VFBC_CMD_END <= '0'; -- never ends
  
  -- Feed command into VFBC Cmd Port at the beginning of each frame
  VFBC_FEED_CMD_PROC : process (pxlclk) is
  begin
	if rising_edge(pxlclk) then
      if vcnt = 0 and hcnt = 1 then
			vfbc_cmd_data_i <= vfbc_cmd0;
			vfbc_cmd_write_i <= '1';
		elsif vcnt = 0 and hcnt = 2 then
			vfbc_cmd_data_i <= vfbc_cmd1;
			vfbc_cmd_write_i <= '1';
		elsif vcnt = 0 and hcnt = 3 then
			vfbc_cmd_data_i <= vfbc_cmd2;
			vfbc_cmd_write_i <= '1';
		elsif vcnt = 0 and hcnt = 4 then
			vfbc_cmd_data_i <= vfbc_cmd3;
			vfbc_cmd_write_i <= '1';
		else
			vfbc_cmd_data_i <= (others=>'0');
			vfbc_cmd_write_i <= '0';
		end if;
	end if;
  end process VFBC_FEED_CMD_PROC;
  
  --------------------------------
  -- VFBC Read Logic
  --------------------------------
  VFBC_RD_CLK <= pxlclk;
  VFBC_RD_RESET <= vfbc_rd_reset_i;
  VFBC_RD_FLUSH <= '0';
  VFBC_RD_READ <= active_video_i;
  --TODO: allow non 128 byte alligned parameters by implementing Burst stop logic
  VFBC_RD_END_BURST <= '0';
  
  -- Reset VFBC Read Port at the beginning of each frame
  VFBC_READ_DATA_PROC : process (pxlclk) is
  begin
	if rising_edge(pxlclk) then
      if vcnt = 0 and hcnt < 10 then
			vfbc_rd_reset_i <= '1';
		else
			vfbc_rd_reset_i <= '0';
		end if;
	end if;
  end process VFBC_READ_DATA_PROC;
  
  NO_INPUT_PROC : process (pxlclk) is
  begin
	if rising_edge(pxlclk) then
      if frame_reset_reg = frame_reset then
		   frame_reset_cnt <= frame_reset_cnt + 1;
		else
			frame_reset_cnt <= (others=>'0');			
		end if;
		if (hcnt = 0 and vcnt = 0 and frame_reset_cnt > 30) then
			no_input_signal <= '1';
		else
			no_input_signal <= '0';
		frame_reset_reg <= frame_reset;
		end if;
	end if;
  end process NO_INPUT_PROC;
  
  VFBC_LINE_BUFFER_PROC : process (pxlclk) is
  begin
    if rising_edge(pxlclk) then
	   if (active_video_i = '1') then
 	       if (hcnt(13) = '1') then
		      line_buffer_waddr <= line_buffer_waddr + 1;
		    end if;
		    if (hcnt = hlr) then
		      line_buffer_raddr <= (others => '0');
		    elsif (hcnt > hlr) then
		      line_buffer_raddr <= line_buffer_raddr + 1;
		    else
		      line_buffer_raddr <= (others => '1');
		    end if;
      else
        line_buffer_waddr <= (others => '0');		
		end if;
    end if; 
  end process VFBC_LINE_BUFFER_PROC;

  -- Instantiate BRAM Line Buffer
  BRAM_640P_LINE_BUFFER : BRAM_TDP_MACRO
    generic map (
      BRAM_SIZE => "18Kb", -- Target BRAM, "9Kb" or "18Kb" 
      DEVICE => "SPARTAN6", -- Target Device: "VIRTEX5", "VIRTEX6", "SPARTAN6" 
      DOA_REG => 0, -- Optional port A output register (0 or 1)
      DOB_REG => 0, -- Optional port B output register (0 or 1)
      INIT_A => X"000000000", -- Initial values on A output port
      INIT_B => X"000000000", -- Initial values on B output port
      INIT_FILE => "NONE",
      READ_WIDTH_A => 16,   -- Valid values are 1-36 
      READ_WIDTH_B => 16,   -- Valid values are 1-36
      SIM_COLLISION_CHECK => "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE" 
      SRVAL_A => X"000000000",   -- Set/Reset value for A port output
      SRVAL_B => X"000000000",   -- Set/Reset value for B port output
      WRITE_MODE_A => "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_MODE_B => "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_WIDTH_A => 16, -- Valid values are 1-36
      WRITE_WIDTH_B => 16, -- Valid values are 1-36
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E => X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_00 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 => X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 => X"0000000000000000000000000000000000000000000000000000000000000000")
    port map (
      DOA => unused_dout,          -- Output port-A data
      DOB => line_buffer_dout,     -- Output port-B data
      ADDRA => line_buffer_waddr,  -- Input port-A address
      ADDRB => line_buffer_raddr,  -- Input port-B address
      CLKA => pxlclk,              -- Input port-A clock
      CLKB => pxlclk,              -- Input port-B clock
      DIA => VFBC_RD_DATA,         -- Input port-A data
      DIB => x"0000",              -- Input port-B data
      ENA => active_video_i,       -- Input port-A enable
      ENB => active_video_i,       -- Input port-B enable
      REGCEA => '0',               -- Input port-A output register enable
      REGCEB => '0',               -- Input port-B output register enable
      RSTA => '0',                 -- Input port-A reset
      RSTB => '0',                 -- Input port-B reset
      WEA => "11",                 -- Input port-A write enable
      WEB => "00"                  -- Input port-B write enable
    );
  
end IMP;
  


